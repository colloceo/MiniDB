# MiniDB: A Custom RDBMS from First Principles

**MiniDB** is a lightweight, relational database engine built from scratch in Python. It was designed to demonstrate core database internals‚Äîincluding B-Tree indexing concepts, Hash Joins, and Atomic Persistence‚Äîwithout relying on external database libraries like SQLite.

> **Note:** This project was built for the **Pesapal Junior Dev Challenge '26**.

## ÔøΩ Demo Video
[Click here to watch the 2-minute System Demo]

## ÔøΩüèóÔ∏è Architecture Overview

The system is organized into four modular layers, designed to mimic a production RDBMS:

```mermaid
graph TD
    UI[UI Layer: Web Dashboard] -->|HTTP POST| API[Flask Routes]
    API -->|SQL String| P[SQL Parser]
    P -->|Command Object| E[Execution Engine]
    E -->|Read/Write| S[Storage Layer]
    S -->|JSON & Fsync| D[(Data Files)]
    E -.->|O(N) Lookups| H{Hash Index}
```

- **UI Layer**: A Flask-based Admin Dashboard (`app.py`) for visual schema management, data entry, and SQL execution.
- **SQL Parser**: A regex-based engine (`parser.py`) that translates SQL into command objects. Supports `CREATE`, `INSERT`, `SELECT` (with complex `WHERE`), `UPDATE`, `DELETE`, and `JOIN`.
- **Database Engine**: The query coordinator (`database.py`). It replaces naive $O(N^2)$ loops with $O(N)$ Hash Joins for optimized performance.
- **Storage Layer**: Handles data persistence (`table.py`). Implements Atomic Writes (Write-Ahead Logging concept) and File Locking to ensure data integrity.

## üß† Key Engineering Decisions

### 1. Performance: Hash Joins over Nested Loops
Naive database implementations use Nested Loop Joins ($O(N \times M)$). MiniDB implements a Hash Join algorithm:
- **Build Phase**: Constructs an in-memory Hash Map of the smaller table.
- **Probe Phase**: Scans the larger table and performs $O(1)$ lookups against the map.
- **Result**: Reduces query time from linear growth to near-constant time for lookups.

### 2. Reliability: Atomic Writes (Crash Safety)
To prevent data corruption during power failures, MiniDB uses an atomic save strategy:
1. Writes data to a temporary file (`table.tmp`).
2. Forces a hardware flush using `os.fsync`.
3. Performs an atomic swap using `os.replace`.
- **Result**: The database is never in a "half-written" state.

### 3. Consistency: ACID Transactions
MiniDB implements a robust Transaction Manager within the engine:
- **Staging Area**: Changes during a transaction are kept in a session-specific buffer.
- **Atomicity**: Supports `BEGIN`, `COMMIT`, and `ROLLBACK` for multi-statement workflows.
- **Integrity**: Ensures that if a process crashes mid-transaction, no partial data is committed to disk.

### 4. Concurrency: Multi-Process File Locking
To support multiple users/processes, MiniDB implements a global `LockManager`:
- **Pessimistic Locking**: Leverages file-based locks (`.lock` files) to prevent race conditions during write operations.
- **Timeout & Retry**: Includes a retry mechanism with configurable timeouts for busy database scenarios.
- **Stale Lock Cleanup**: Includes logic to detect and remove "dead" locks left behind by crashed processes.

### 5. Safety: Strict Type System
Unlike basic file stores, MiniDB enforces a schema:
- **Type Validation**: Rejects attempts to insert strings into `INT` columns.
- **Constraints**: Enforces `PRIMARY KEY` uniqueness and `FOREIGN KEY` referential integrity.

## üöÄ How to Run

### Prerequisites
- Python 3.10+
- Flask (for the web dashboard)

### Installation
1. Clone the repository:
   ```bash
   git clone https://github.com/collins-odhiambo/minidb.git
   cd minidb
   ```
2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

### Running the App
1. Start the Web Admin Dashboard:
   ```bash
   python app.py
   ```
   Visit `http://127.0.0.1:5000` to access the UI.

2. To use the CLI (REPL) mode:
   ```bash
   python main.py
   ```

## ‚ö†Ô∏è Known Limitations (Prototype Scope)
- **SQL Breadth**: Supports a subset of SQL syntax. Complex nested subqueries are not yet implemented.
- **Data Scale**: Designed for lightweight datasets; performance may degrade with millions of records as it is memory-resident during execution.

## üôè Acknowledgements & AI Usage
This project was built as part of the Pesapal Junior Dev Challenge '26.
- **Architecture & Logic**: Designed by Collins Odhiambo.
- **Code Generation**: Boilerplate regex parsing and Flask templates generated by AI (Gemini 2.0).
- **Algorithm Optimization**: AI assisted in refactoring the Join algorithm and implementing the concurrency lock manager.
- **Verification**: All code was manually reviewed, tested, and integrated by the author.

Built with code, sweat, and Python.
